<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8"/>
		<title></title>
		
	</head>
	<body>
		<h2>JQuery/AJAX</h2>
		<h3>JQuery总结</h3>
		<p>概述：</p>
		<p>jQuery是一个轻量级javascript库兼容CSS3，还兼容各种浏览器。
使用户能更方便地处理HTML文档、事件、实现动画效果，并且方便地为网站提供Ajax交互。</p>
        <p>特点：</p>
        <div>
        	<pre>
以插件的形式持续地通过开发加入新的功能
获取页面的部分内容
修改页面的外观
修改页面的内容
在页面中响应用户的交互
给页面加上动画
无刷新返回服务器端的信息 ajax
还提供了改进基本的 JavaScript 结构，如迭代和数组操作。
        	</pre>
        </div>
        
        <p>使用：</p>
        <div>
        	<pre>
$(document).ready(function(){ // 在这里写你的代码...}); //指的是：加载页面后 再执行这段JS语句。
简写方式：
$(function($){// 你可以在这里继续使用$作为别名...});
绑定一个在DOM文档载入完成后执行的函数
同一个页面上可以多次使用
请确保在 <body> 元素的onload事件中没有注册函数，否则不会触发$(document).ready()事件。
        	</pre>
        </div>
        
        <p>jquery选择器</p>
        <div>
        	<pre>
$('#id')根据给定的ID匹配一个元素
$('.class')根据给定的类匹配元素
$('tag')根据给定的元素名匹配所有元素
$('li:eq(1)')获取下标为1的li标签
$('#box li:last')获取id为box的对象里面最后一个li标签
$('#box li:first')获取id为box的对象里面第一个li标签
利用jQuery不但可以获得代码的最大兼容性，而且可以避免很多js错误的发生。
因为jQuery有一个特色：如果获取不到对象，那后面的操作就自动地不会执行了，而且不报错。不像原生态的js语句
        	</pre>
        </div>
        
        <p>通过关系查找</p>
        <div>
        	<pre>
$('.class').siblings();查找同辈的所有元素
$('.class').children();查找子元素
$('.class').next();查找同辈的下一个元素
$('.class').nextAll();该元素之后所有的同辈元素
$('.class').prev();查找同辈的上一个元素
$('.class').prevAll();该元素之前所有的同辈元素
$('.class').parent();查找元素的父辈
        	</pre>
        </div>
        
        <p>//原生态的js过程代码，这种方法获取到的是 DOM对象</p>
        <div>
        	<pre>
var box = document.getElementById('box');
var $box = $(box);//从DOM对象转成jQuery对象
alert($box.html());
var $box=$('#box');//jquery获取到jquery对象
var box=$box[0];//jquery对象获取到DOM对象
//或者是
var box=$box.get(0);
alert(box.innerHTML);
        	</pre>
        </div>
        
        <p>对样式的操作</p>
        <div>
        	<pre>
添加class$('li').addClass(class|fn);
删除class$("p").removeClass(class|fn);
添加/删除class$(".div").toggleClass(class);
说明：如果存在（不存在）就删除（添加）一个类。
直接操作csscss();
$("p").css("color");获得颜色值
$("p").css("color","red");设置颜色值
$("p").css({ color: "#ff0011", background: "blue" });
        	</pre>
        </div>
        <p>对属性的操作</p>
        <div>
        	<pre>
attr()设置或返回被选元素的属性值。
获取属性 $("li").attr("title");
设置属性$("li").attr("title",'value');
        	</pre>
        </div>
        
        <p>设置多个属性</p>
        <div>
        	<pre>
$("img").attr({src:"test.jpg",alt:"TestImage"});
设置多个对象的属性，利用回调函数做：
$('li').attr('title',function(index,attr){
this.title="wengdo"+index;
});
        	</pre>
        </div>
        
        <p>对内容的操作</p>
        <div>
        	<pre>
取得内容
//1)取得第一个匹配元素的html内容。
$('.select').html()
//2)取得匹配元素的文本内容，去除里面的标签，获取多个的内容
$('.select').text();

删除内容
$('.delete').remove();//1)将该元素整个干掉
$(".delete").empty();//2)将该元素的子元素或者内容清空

设置/修改内容
//1)设置匹配元素的html内容。
$('.select').html('设置所有选中元素的内容');
//2)设置匹配元素的不同的内容。
$('.cla').html(function(index,html){
this.innerHTML= html+index;
});

增加内容
// 向每个匹配的元素内部追加内容。 追加到末尾
$('.cla').append("<b>追加</b>");
//每个匹配的元素内部前置内容。
$('.cla').prepend("<b>追加</b>");
//在每个匹配的元素之后插入内容。
$("p").after("<b>Hello</b>");
//在每个匹配的元素之前插入内容。
$("p").before("<b>Hello</b>");
        	</pre>
        </div>
        
        <p>事件动画</p>
        <div>
        	<pre>
click触发每一个匹配元素的click事件。
//将页面内所有段落点击后隐藏。
$("p").click( function () { $(this).hide(); });
mouseover当鼠标指针位于元素上方时，会发生 mouseover 事件。
//当鼠标指针位于元素上方时时，改变元素的背景色：
$("p").mouseover(function(){
$("p").css("background-color","yellow");
});


bind()为每个匹配元素的特定事件绑定事件处理函数。
// 当每个段落被点击的时候，弹出其文本。
$("p").bind("click", function(){
alert( $(this).text() );
});

合成事件
hover()一个模仿悬停事件（鼠标移动到一个对象上面及移出这个对象）的方法。这是一个自定义的方法，它为频繁使用的任务提供了一种“保持在其中”的状态。
$(".class").hover(
function () {
$(this).addClass("hover");
},
function () {
$(this).removeClass("hover");
}
);


模拟事件
trigger();在每一个匹配的元素上触发某类事件。
//模拟客户提交表单
$("form:first").trigger("submit");
//模拟客户点击
$('.cla').trigger('click');
//模拟元素获得焦点
$('#text').trigger('focus');


表单操作
val()获得或者设置匹配元素的当前值。
//获取输入框user的值
$("input[name='user']").val();
//修改输入框user的值
$("input[name='user']").val(2323);
prop()修改、获取表单属性值
//获取到属性值
$("input[name='user']").prop('value');
// 禁用
$("input[name='user']").prop('disabled',true);
//选中
$("input[name='love']").prop('checked',true);
        	</pre>
        </div>
        
        <p>动画</p>
        <div>
        	<pre>
show()显示隐藏的匹配元素
//将选中的元素显示出来
$("p").show();
//将选中的元素缓慢的显示出来，有slow、normal、fast 或者是毫秒数
$("p").show("slow");
//回调函数，完成效果后执行这个函数
$("p").show("fast",function(){
$(this).text("show time !");
});
hide()隐藏显示的元素
//将选中的元素隐藏出来
$("p").hide();
//将选中的元素缓慢的隐藏出来，有slow、normal、fast 或者是毫秒数
$("p").hide("slow");
//回调函数，完成效果后执行这个函数
$("p").hide("fast",function(){
alert($(this).text());
});
fadeIn()改变不透明度，直到显示
fadeOut()改变不透明度，直到"消失"
slideUp()改变高度，直到隐藏
slideDown() 改变高度，直到完全显示
animate()自定义动画
可以根据自己的需要进行定制动画。
//同时执行
$(".one").animate({
width: "800px",
height: "500px",
fontSize: "20px",
borderWidth:'10px'
}, 1000 );
        	</pre>
        </div>
        
        <p>技巧：回到顶部按钮</p>
        <div>
        	<pre>
通过使用 jQuery 中的 animate 和 scrollTop 方法，无需插件便可创建一个简单地回到顶部动画：

JavaScript

// Back to top
$('a.top').click(function (e) {
  e.preventDefault();
  $(document.body).animate({scrollTop: 0}, 800);
});

<!-- Create an anchor tag -->
<a class="top" href="#">Back to top</a>
将 scrollTop 的值改为你想要 scrollbar 停止的地方。然后你要做的就是，设置在 800 毫秒内回到顶部。
        	</pre>
        </div>
        
        <h3>AJAX</h3>
        <p>ajax所包含的技术</p>
        <div>
        	<pre>
1.使用CSS和XHTML来表示。
2. 使用DOM模型来交互和动态显示。
3.使用XMLHttpRequest来和服务器进行异步通信。
4.使用javascript来绑定和调用。
在上面几中技术中，除了XmlHttpRequest对象以外，其它所有的技术都是基于web标准并且已经得到了广泛使用的，
XMLHttpRequest虽然目前还没有被W3C所采纳，但是它已经是一个事实的标准，因为目前几乎所有的主流浏览器都支持它。
        	</pre>
        </div>
        
        <p>ajax原理和XmlHttpRequest对象</p>
        <div>
        	<pre>
  Ajax的原理简单来说通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用javascript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。要清楚这个过程和原理，我们必须对 XMLHttpRequest有所了解。
　XMLHttpRequest是ajax的核心机制，它是在IE5中首先引入的，是一种支持异步请求的技术。简单的说，也就是javascript可以及时向服务器提出请求和处理响应，而不阻塞用户。达到无刷新的效果。
  　所以我们先从XMLHttpRequest讲起，来看看它的工作原理。
  　首先，我们先来看看XMLHttpRequest这个对象的属性。
  　　它的属性有：
  　　onreadystatechange  每次状态改变所触发事件的事件处理程序。
  　　responseText     从服务器进程返回数据的字符串形式。
  　　responseXML    从服务器进程返回的DOM兼容的文档数据对象。
  　　status           从服务器返回的数字代码，比如常见的404（未找到）和200（已就绪）
  　　status Text       伴随状态码的字符串信息
  　　readyState       对象状态值
　　　　0 (未初始化) 对象已建立，但是尚未初始化（尚未调用open方法）
　　　　1 (初始化) 对象已建立，尚未调用send方法
　　　　2 (发送数据) send方法已调用，但是当前的状态及http头未知
　　　　3 (数据传送中) 已接收部分数据，因为响应及http头不全，这时通过responseBody和responseText获取部分数据会出现错误，
　　　　4 (完成) 数据接收完毕,此时可以通过通过responseXml和responseText获取完整的回应数据
 
　　但是，由于各浏览器之间存在差异，所以创建一个XMLHttpRequest对象可能需要不同的方法。这个差异主要体现在IE和其它浏览器之间。下面是一个比较标准的创建XMLHttpRequest对象的方法。
        	</pre>
        </div>
        <br/>
        <div>
        	<pre>
    function CreateXmlHttp() {

    //非IE浏览器创建XmlHttpRequest对象
    if (window.XmlHttpRequest) {
        xmlhttp = new XmlHttpRequest();
    }

    //IE浏览器创建XmlHttpRequest对象
    if (window.ActiveXObject) {
        try {
            xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
        }
        catch (e) {
            try {
                xmlhttp = new ActiveXObject("msxml2.XMLHTTP");
            }
            catch (ex) { }
        }
    }
}

function Ustbwuyi() {

    var data = document.getElementById("username").value;
    CreateXmlHttp();
    if (!xmlhttp) {
        alert("创建xmlhttp对象异常！");
        return false;
    }

    xmlhttp.open("POST", url, false);

    xmlhttp.onreadystatechange = function () {
        if (xmlhttp.readyState == 4) {
            document.getElementById("user1").innerHTML = "数据正在加载...";
            if (xmlhttp.status == 200) {
                document.write(xmlhttp.responseText);
            }
        }
    }
    xmlhttp.send();
}
        	</pre>
        </div>
        
        <div>
        	<pre>      		
　　如上所示，函数首先检查XMLHttpRequest的整体状态并且保证它已经完成（readyStatus=4），即数据已经发送完毕。然后根据服务器的设定询问请求状态，如果一切已经就绪（status=200），那么就执行下面需要的操作。
对于XmlHttpRequest的两个方法，open和send，其中open方法指定了：
a、向服务器提交数据的类型，即post还是get。
b、请求的url地址和传递的参数。
c、传输方式，false为同步，true为异步。默认为true。如果是异步通信方式(true)，客户机就不等待服务器的响应；
如果是同步方式(false)，客户机就要等到服务器返回消息后才去执行其他操作。我们需要根据实际需要来指定同步方式，
在某些页面中，可能会发出多个请求，甚至是有组织有计划有队形大规模的高强度的request，而后一个是会覆盖前一个的，这个时候当然要指定同步方式。
    Send方法用来发送请求。
 
　　知道了XMLHttpRequest的工作流程，我们可以看出，XMLHttpRequest是完全用来向服务器发出一个请求的，它的作用也局限于此，但它的作用是整个ajax实现的关键，
因为ajax无非是两个过程，发出请求和响应请求。并且它完全是一种客户端的技术。而XMLHttpRequest正是处理了服务器端和客户端通信的问题所以才会如此的重要。
　　现在，我们对ajax的原理大概可以有一个了解了。我们可以把服务器端看成一个数据接口，它返回的是一个纯文本流，当然，这个文本流可以是XML格式，可以是Html，可以是Javascript代码，也可以只是一个字符串。
这时候，XMLHttpRequest向服务器端请求这个页面，服务器端将文本的结果写入页面，这和普通的web开发流程是一样的，不同的是，客户端在异步获取这个结果后，不是直接显示在页面，而是先由javascript来处理，然后再显示在页面。
至于现在流行的很多ajax控件，比如magicajax等，可以返回DataSet等其它数据类型，只是将这个过程封装了的结果，本质上他们并没有什么太大的区别。
        	</pre>
        </div>
        
        <p>ajax的优/缺点</p>
        <div>
        	<pre>
  //优点:
  1、最大的一点是页面无刷新，在页面内与服务器通信，给用户的体验非常好。
　 2、使用异步方式与服务器通信，不需要打断用户的操作，具有更加迅速的响应能力。
　 3、可以把以前一些服务器负担的工作转嫁到客户端，利用客户端闲置的能力来处理，减轻服务器和带宽的负担，节约空间和宽带租用成本。
并且减轻服务器的负担，ajax的原则是“按需取数据”，可以最大程度的减少冗余请求，和响应对服务器造成的负担。
  4、基于标准化的并被广泛支持的技术，不需要下载插件或者小程序。

  //缺点:
  1、ajax干掉了back按钮，即对浏览器后退机制的破坏。后退按钮是一个标准的web站点的重要功能，但是它没法和js进行很好的合作。
  2、安全问题
  3、对搜索引擎的支持比较弱。
  4、破坏了程序的异常机制。
  5、另外，像其他方面的一些问题，比如说违背了url和资源定位的初衷
  6、一些手持设备（如手机、PDA等）现在还不能很好的支持ajax，比如说我们在手机的浏览器上打开采用ajax技术的网站时，它目前是不支持的，当然，这个问题和我们没太多关系。
        	</pre>
        	
        </div>
        
        <p>ajax的几种框架</p>
        <div>
        	<pre>
    目前我们采用的比较多的ajax框架主要有ajax.dll,ajaxpro.dll,magicajax.dll 以及微软的atlas框架。Ajax.dll和Ajaxpro.dll这两个框架差别不大，而magicajax.dll只是封装得更厉害一些，
    比如说它可以直接返回DataSet数据集，前面我们已经说过，ajax返回的都是字符串，magicajax只是对它进行了封装而已。但是它的这个特点可以给我们带来很大的方便，比如说我们的页面有一个列表，而列表的数据是不断变化的，
    那么我们可以采用magicajax来处理，操作很简单，添加magicajax之后，将要更新的列表控件放在magicajax的控件之内，然后在pageload里面定义更新间隔的时间就ok了，atlas的原理和magicajax差不多。
    但是，需要注意的一个问题是，这几种框架都只支持IE，没有进行浏览器兼容方面的处理，用反编译工具察看他们的代码就可以知道。
 除了这几种框架之外，我们平时用到的比较多的方式是自己创建xmlHttpRequest对象，这种方式和前面的几种框架相比更具有灵活性。另外，在这里还提一下aspnet2.0自带的异步回调接口，它和ajax一样也可以实现局部的无刷新，但它的实现实际上也是基于xmlhttprequest对象的，另外也是只支持IE，当然这是微软的一个竞争策略。
        	</pre>
        </div>

	</body>
</html>
